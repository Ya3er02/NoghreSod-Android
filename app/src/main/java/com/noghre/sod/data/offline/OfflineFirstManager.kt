package com.noghre.sod.data.offline

import android.util.Log\nimport com.noghre.sod.data.local.dao.OfflineOperationDao\nimport com.noghre.sod.data.local.entity.OfflineOperationEntity\nimport com.noghre.sod.data.model.NetworkResult\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.flow\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n/**\n * Manager for offline-first sync operations.\n *\n * Handles queuing operations when offline, syncing when online,\n * and managing retry logic with exponential backoff.\n *\n * @param offlineOperationDao Database access object for offline operations\n */\n@Singleton\nclass OfflineFirstManager @Inject constructor(\n    private val offlineOperationDao: OfflineOperationDao\n) {\n    companion object {\n        private const val TAG = \"OfflineFirstManager\"\n    }\n\n    /**\n     * Queue an operation to be synced later.\n     *\n     * @param type Operation type (ADD_TO_CART, REMOVE_FROM_CART, etc)\n     * @param resourceId The ID of the resource being operated on\n     * @param payload JSON string with operation details\n     * @return The ID of the queued operation\n     */\n    suspend fun queueOperation(\n        type: String,\n        resourceId: String,\n        payload: String\n    ): String {\n        val operation = OfflineOperationEntity(\n            type = type,\n            resourceId = resourceId,\n            payload = payload,\n            status = OfflineOperationEntity.STATUS_PENDING\n        )\n        offlineOperationDao.insertOperation(operation)\n        Log.d(TAG, \"Operation queued: ${operation.id} (type: $type)\")\n        return operation.id\n    }\n\n    /**\n     * Get all pending operations.\n     *\n     * @return Flow of pending operations\n     */\n    fun getPendingOperations(): Flow<List<OfflineOperationEntity>> {\n        return offlineOperationDao.getPendingOperations()\n    }\n\n    /**\n     * Get next operation to sync.\n     *\n     * @return Next pending operation or null\n     */\n    suspend fun getNextOperationToSync(): OfflineOperationEntity? {\n        val operation = offlineOperationDao.getNextPendingOperation()\n        if (operation != null) {\n            offlineOperationDao.markAsSyncing(operation.id)\n            Log.d(TAG, \"Marked operation ${operation.id} as syncing\")\n        }\n        return operation\n    }\n\n    /**\n     * Mark operation as successfully synced.\n     *\n     * @param operationId The operation ID\n     */\n    suspend fun markOperationAsSuccessful(operationId: String) {\n        offlineOperationDao.markAsSuccessful(operationId)\n        Log.d(TAG, \"Operation $operationId marked as successful\")\n    }\n\n    /**\n     * Mark operation as failed and handle retry.\n     *\n     * @param operationId The operation ID\n     * @param errorMessage The error message\n     * @return True if operation will be retried, false if max retries exceeded\n     */\n    suspend fun markOperationAsFailed(operationId: String, errorMessage: String? = null): Boolean {\n        val operation = offlineOperationDao.getOperationById(operationId) ?: return false\n        offlineOperationDao.markAsFailed(operationId, errorMessage)\n        \n        val willRetry = operation.shouldRetry()\n        if (willRetry) {\n            Log.d(TAG, \"Operation $operationId failed. Retry attempt ${operation.retryCount + 1}/${operation.maxRetries}\")\n        } else {\n            Log.e(TAG, \"Operation $operationId failed. Max retries exceeded.\")\n        }\n        return willRetry\n    }\n\n    /**\n     * Sync pending operations with retry logic.\n     *\n     * @param syncCallback Callback to actually perform the sync (should return true on success)\n     * @return Flow of sync results\n     */\n    fun syncPendingOperations(\n        syncCallback: suspend (OfflineOperationEntity) -> Boolean\n    ): Flow<SyncResult> = flow {\n        Log.d(TAG, \"Starting sync of pending operations\")\n        \n        val pendingCount = offlineOperationDao.getPendingOperationCount()\n        if (pendingCount == 0) {\n            emit(SyncResult.NoOperationsToSync)\n            return@flow\n        }\n\n        var successCount = 0\n        var failureCount = 0\n        var retryCount = 0\n\n        while (true) {\n            val operation = getNextOperationToSync() ?: break\n\n            try {\n                Log.d(TAG, \"Syncing operation: ${operation.id}\")\n                emit(SyncResult.SyncingOperation(operation))\n                \n                val success = syncCallback(operation)\n                \n                if (success) {\n                    markOperationAsSuccessful(operation.id)\n                    successCount++\n                    emit(SyncResult.OperationSuccess(operation))\n                } else {\n                    val willRetry = markOperationAsFailed(operation.id, \"Sync callback returned false\")\n                    if (willRetry) {\n                        retryCount++\n                        val delay = operation.getNextRetryDelay()\n                        Log.d(TAG, \"Operation ${operation.id} will retry after ${delay}ms\")\n                        emit(SyncResult.OperationRetry(operation, delay))\n                        delay(delay)\n                    } else {\n                        failureCount++\n                        emit(SyncResult.OperationFailed(operation, \"Max retries exceeded\"))\n                    }\n                }\n            } catch (e: Exception) {\n                Log.e(TAG, \"Error syncing operation ${operation.id}\", e)\n                val willRetry = markOperationAsFailed(operation.id, e.message)\n                if (willRetry) {\n                    retryCount++\n                    val delay = operation.getNextRetryDelay()\n                    Log.d(TAG, \"Operation ${operation.id} will retry after ${delay}ms due to exception\")\n                    emit(SyncResult.OperationRetry(operation, delay))\n                    delay(delay)\n                } else {\n                    failureCount++\n                    emit(SyncResult.OperationFailed(operation, e.message ?: \"Unknown error\"))\n                }\n            }\n        }\n\n        val totalOperations = successCount + failureCount + retryCount\n        Log.d(TAG, \"Sync complete. Success: $successCount, Failed: $failureCount, Retrying: $retryCount\")\n        emit(SyncResult.SyncComplete(successCount, failureCount, retryCount))\n    }\n\n    /**\n     * Get operations by type.\n     *\n     * @param type Operation type\n     * @return List of operations\n     */\n    suspend fun getOperationsByType(type: String): List<OfflineOperationEntity> {\n        return offlineOperationDao.getOperationsByType(type)\n    }\n\n    /**\n     * Get operations by resource ID.\n     *\n     * @param resourceId The resource ID\n     * @return List of operations\n     */\n    suspend fun getOperationsByResourceId(resourceId: String): List<OfflineOperationEntity> {\n        return offlineOperationDao.getOperationsByResourceId(resourceId)\n    }\n\n    /**\n     * Check if there are pending operations.\n     *\n     * @return True if there are pending operations\n     */\n    suspend fun hasPendingOperations(): Boolean {\n        return offlineOperationDao.hasPendingOperations()\n    }\n\n    /**\n     * Get count of pending operations.\n     *\n     * @return Number of pending operations\n     */\n    suspend fun getPendingOperationCount(): Int {\n        return offlineOperationDao.getPendingOperationCount()\n    }\n\n    /**\n     * Clear successfully synced operations (cleanup).\n     */\n    suspend fun clearSuccessfulOperations() {\n        offlineOperationDao.deleteSuccessfulOperations()\n        Log.d(TAG, \"Cleared successful operations\")\n    }\n\n    /**\n     * Clear operations older than specified time.\n     *\n     * @param ageInMillis Delete operations older than this duration\n     */\n    suspend fun clearOldOperations(ageInMillis: Long = 24 * 60 * 60 * 1000) {\n        val cutoffTime = System.currentTimeMillis() - ageInMillis\n        offlineOperationDao.deleteOperationsOlderThan(cutoffTime)\n        Log.d(TAG, \"Cleared operations older than $ageInMillis ms\")\n    }\n\n    /**\n     * Delete a specific operation.\n     *\n     * @param operationId The operation ID\n     */\n    suspend fun deleteOperation(operationId: String) {\n        offlineOperationDao.deleteOperationById(operationId)\n        Log.d(TAG, \"Deleted operation $operationId\")\n    }\n}\n\n/**\n * Sealed class representing sync results.\n */\nseal class SyncResult {\n    data class SyncingOperation(val operation: OfflineOperationEntity) : SyncResult()\n    data class OperationSuccess(val operation: OfflineOperationEntity) : SyncResult()\n    data class OperationFailed(val operation: OfflineOperationEntity, val errorMessage: String) : SyncResult()\n    data class OperationRetry(val operation: OfflineOperationEntity, val delayMs: Long) : SyncResult()\n    data class SyncComplete(val successCount: Int, val failureCount: Int, val retryCount: Int) : SyncResult()\n    object NoOperationsToSync : SyncResult()\n}\n